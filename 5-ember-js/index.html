<!doctype html><html lang="de"><head><meta charset="utf-8"><title>An ambitious introduction to Ember.js - pichfl talks</title><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="//pichfl.github.io/talks/assets/main.8f0e536b.css"><style>section:first-child,
section:nth-child(3) {
  background-image: url(emberjs.9f80790d.svg);
  background-repeat: no-repeat;
  background-position: center;
}
section:nth-child(2) img {
  margin-top: calc(50vh - 285px);
}
h1 {
  margin-bottom: 2.5em;
}</style></head><body><div class="site"><article class="slides"><section id="intro" class="slides__slide--title"><p></p><h1>An ambitious introduction to <span class="aux">Ember.js</span></h1><p></p><p><em>By Florian Pichler</em></p><footer><a href="../">More talks by @pichfl</a></footer></section><section id="tomster" class="slides__slide"><p><img src="./original.765e5ba0.png" alt="tomster"></p></section><section id="intro2" class="slides__slide--title"><p></p><h1>Ein ambitionierter Einstieg in <span class="aux">Ember.js</span></h1><p></p><p><em>Von Florian Pichler</em></p><footer><a href="../">Mehr Vorträge</a></footer></section><section id="history" class="slides__slide"><h2 id="geschichte">Geschichte</h2><ul><li>Ember.js ist ein Fork von SproutCore, berüchtigt für Apples<span class="widont">&nbsp;</span>MobileMe</li><li>Von Yehuda Katz (core team member of jQuery, Ruby on Rails, …) und vielen<span class="widont">&nbsp;</span>anderen</li><li><span class="caps">MVC</span>-Framework für “single-page web<span class="widont">&nbsp;</span>applications”</li></ul></section><section id="ambitious" class="slides__slide"><h2 id="-a-framework-for-creating-ambitious-web-applications-">“A framework for creating ambitious web<span class="widont">&nbsp;</span>applications”</h2><ul><li>Open-source. Entwicklung wird durch RFCs<span class="widont">&nbsp;</span>beeinflusst</li><li>Einsatz von <a href="http://semver.org">Semantic<span class="widont">&nbsp;</span>Versioning</a></li><li>Konvention vor Konfiguration (wie auch bei<span class="widont">&nbsp;</span>Rails)</li><li>Stark und trotzdem flexibel durch Einhaltung von Konzepten der<span class="widont">&nbsp;</span>Core-Entwickler</li><li>Viele Sponsoren statt einer Firma als Owner: Yahoo, LinkedIn, Bustle, Yapp, Tilde,<span class="widont">&nbsp;</span>Square</li><li>Prominente Nutzer: Discourse, Groupon, Vine, Nordstrom, Twitch.tv, Apple Music, Sony <span class="caps">PSN</span>,<span class="widont">&nbsp;</span>…</li></ul></section><section id="features" class="slides__slide"><h2 id="meta-features">Meta Features</h2><ul><li><span class="caps">ES2015</span> modules (via<span class="widont">&nbsp;</span>Babel.js)</li><li>Ember-<span class="caps">CLI</span></li><li>Ember Inspector</li><li>Release-Zyklus von 6 Wochen, mit Beta-Releases und canary<span class="widont">&nbsp;</span>channel</li><li><span class="caps">LTS</span> Support</li><li>Freundliche und hilfsbereite<span class="widont">&nbsp;</span>Community</li></ul></section><section id="basics" class="slides__slide"><h2 id="basic-concepts">Basic concepts</h2><ul><li>Ember Objects</li><li>Routes</li><li>Services</li><li>Templates</li><li>Components</li><li>(Controllers)</li><li>Models (Ember Data)</li></ul></section><section id="ember-objects" class="slides__slide"><h2 id="ember-object">Ember.Object</h2><ul><li>(noch) Alternative zu <span class="caps">ES2015</span> Klassen,<span class="widont">&nbsp;</span>etc.</li><li>Unterstützung für die Überwachung von Änderungen an Eigenschaften von<span class="widont">&nbsp;</span>Objekten*</li><li>Klassen-System mit Mixins, Extending,<span class="widont">&nbsp;</span>Constructors</li><li>Ember.Enumerable liefert Arrays mit<span class="widont">&nbsp;</span><span class="caps">KVO</span>-Support</li></ul><p><br>* auch bekannt als Key Value Observer / <span class="caps">KVO</span>. <code>Object.oberserve()</code> sollte ein ähnliches Verhalten liefern, ist aber obsolet. Zukünftig könnte Ember auf <code>Proxy</code> setzen.</p></section><section id="classes-instances" class="slides__slide"><h2 id="klassen-instanzen-reopening">Klassen, Instanzen, Reopening</h2><ul><li>Neue Klassen durch <code>.extend({})</code> von <code>Ember.Object</code></li><li>Neue Instanzen durch <code>.create({})</code> einer Klasse.</li><li>Sowohl Instanzen als auch deren Basis-Klasse lassen sich durch <code>.reopen()</code> bzw. <code>.reopenClass</code> zur Laufzeit verändern, falls nötig. Dieses Verhalten erlaubt es Addons zum Start der Ember-App Verhalten nachzurüsten, z.B. Event Handler oder Computed<span class="widont">&nbsp;</span>Properties.</li></ul></section><section id="computed" class="slides__slide"><h2 id="computed-properties">Computed Properties</h2><ul><li>Makros mit automatischem Caching für<span class="widont">&nbsp;</span>Ergebnisse</li><li>Cache-Invalidation erfolgt automatisch durch Angabe von<span class="widont">&nbsp;</span>Abhängigkeiten</li><li>Durch das Cache nur unwesentlich langsamer als statische<span class="widont">&nbsp;</span>Eigenschaften</li><li>Unterstützung für Getter/Setter (Getter als<span class="widont">&nbsp;</span>Default)</li></ul><pre><code class="lang-js">Ember.Object.extend({
    firstName: <span class="hljs-string">'Jon'</span>,
    lastName: <span class="hljs-string">'Snow'</span>,

    fullName: computed(<span class="hljs-string">'firstName'</span>, <span class="hljs-string">'lastName'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">const</span> firstName = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'firstName'</span>);
        <span class="hljs-keyword">const</span> lastName = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'lastName'</span>);

        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${firstName}</span> <span class="hljs-subst">${lastName}</span>`</span>;
    }),
});
</code></pre></section><section id="computed-macros" class="slides__slide"><h2 id="computed-macros">Computed.Macros</h2><pre><code class="lang-js">computed.and(<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>) <span class="hljs-comment">// A &amp;&amp; B</span>
computed.filterBy(<span class="hljs-string">'C'</span>, <span class="hljs-string">'key'</span>, <span class="hljs-literal">true</span>) <span class="hljs-comment">// _.filter(C, 'key', true)</span>
computed.not(<span class="hljs-string">'D'</span>) <span class="hljs-comment">// === !propD</span>
computed.mapBy(<span class="hljs-string">'E'</span>, <span class="hljs-string">'key'</span>) <span class="hljs-comment">// Object.keys(E)</span>
</code></pre><ul><li>30+ Makros mitgeliefert</li><li>eigene Makros sind leicht zu<span class="widont">&nbsp;</span>erstellen</li><li>Nützlich um Logik aus Templates zu<span class="widont">&nbsp;</span>halten</li><li>Cached Two-Way- und<span class="widont">&nbsp;</span>One-Way-Bindings</li></ul><pre><code class="lang-js">computed.alias(<span class="hljs-string">'serviceName.foo'</span>)
computed.oneWay(<span class="hljs-string">'other.path'</span>) <span class="hljs-comment">// reads until overwritten</span>
computed.readOnly(<span class="hljs-string">'foo.bar'</span>) <span class="hljs-comment">// throws if trying to write</span>
</code></pre></section><section id="routing-router" class="slides__slide"><h2 id="the-router">The router</h2><ul><li>App-Zustand dargestellt durch die<span class="widont">&nbsp;</span><span class="caps">URL</span></li><li>extrem zuverlässig - u.A. Inspiration für den ui-router für<span class="widont">&nbsp;</span>Angular.js</li><li>dynamische <span class="caps">URL</span>-Segemente, Query-Parameter und<span class="widont">&nbsp;</span>Schachtelung</li><li>Autogenerated routes</li></ul><pre><code class="lang-js">Router.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.route(<span class="hljs-string">'entries'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// this.route('index', {path: '/'}); //autogenerated</span>
        <span class="hljs-keyword">this</span>.route(<span class="hljs-string">'new'</span>); <span class="hljs-comment">// entries/new</span>
        <span class="hljs-keyword">this</span>.route(<span class="hljs-string">':entry'</span>); <span class="hljs-comment">// entries/1</span>
    });
});
</code></pre></section><section id="routing-routes" class="slides__slide"><h2 id="routes">Routes</h2><ul><li>Daten laden</li><li>Verstehen und nutzen Promises für Ladezustände und<span class="widont">&nbsp;</span>Fehlerbehandlung</li><li>Template (Component) Setup</li><li>Verarbeitung von Actions</li></ul><pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Ember.Route.extend({
    model() {
        <span class="hljs-comment">// using ember-data</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.store.findAll(<span class="hljs-string">'entry'</span>);

        <span class="hljs-comment">// return jQuery.ajax(…); // works as well</span>
    },

    afterModel(model) {
        <span class="hljs-keyword">if</span> (!model) {
            <span class="hljs-keyword">this</span>.redirect(<span class="hljs-string">'entries.new'</span>);
        }
    },
});
</code></pre></section><section id="services" class="slides__slide"><h2 id="services">Services</h2><ul><li>Langlebige Ember-Objekte, die an vielen Stellen einer App genutzt werden<span class="widont">&nbsp;</span>können</li><li>Beispiele<ul><li>Timer (globaler Tick)</li><li>Lieferant für <span class="caps">UI</span>-Übersetzungen</li><li>Kommunikation mit Scripts außerhalb von<span class="widont">&nbsp;</span>Ember.js</li></ul></li></ul><pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Controller.extend({
    ticktock: Ember.inject.service(),

    now: computed(<span class="hljs-string">'ticktock.pulse'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
    }),
});
</code></pre></section><section id="templates" class="slides__slide"><h2 id="templates">Templates</h2><ul><li><del>Handlebars</del> <del>HTMLBars</del> <ins>Glimmer</ins><ul><li>Über die Jahre wurde die Engine mehrfach getauscht, ohne Mehrarbeit für Nutzer von<span class="widont">&nbsp;</span>Ember</li></ul></li><li>Vorkompilierte Templates ohne Logik, als eigenständige Dateien oder in einer<span class="widont">&nbsp;</span>Component</li><li>Glimmer nutzt ein ähnliches Konzept wie React (Virtual <span class="caps">DOM</span>)<ul><li>Unterscheidung nicht auf <span class="caps">DOM</span>-Ebene, sondern in den<span class="widont">&nbsp;</span>Daten</li></ul></li><li>Glimmer 2: In Typescript geschrieben. „Run-Time-Compiler für <span class="caps">HTML</span>“ - Noch schneller und ohne <span class="caps">API</span>-Changes für<span class="widont">&nbsp;</span>Nutzer</li></ul></section><section id="components" class="slides__slide"><h2 id="components">Components</h2><ul><li>Kombination aus Template und Source<span class="widont">&nbsp;</span>Code</li><li>Orientieren sich an Web<span class="widont">&nbsp;</span>Components</li><li>Unterstützung für Angle-Brackets <code>&lt;a-component /&gt;</code> mit Glimmer 2, aktueller Syntax an Handlebars<span class="widont">&nbsp;</span>orientiert</li><li>Data down, actions up als aktuelle<span class="widont">&nbsp;</span>Empfehlung.</li><li>Live-Cycle-Hooks zur effizienten Nutzung (Setup, Re-Rendering,<span class="widont">&nbsp;</span>etc.)</li><li>Mit Release von Glimmer viele Analogien zu<span class="widont">&nbsp;</span>React</li></ul></section><section id="controllers" class="slides__slide"><h2 id="controllers">Controllers</h2><ul><li>Historisch zuständig für die Manipulation von in einer Route geladenen<span class="widont">&nbsp;</span>Model-Daten</li><li>Noch nicht deprecated, aber Plan besteht, dies mit Ember 3.0 in die Tat umzusetzen und sie nahtlos durch Routable Components zu<span class="widont">&nbsp;</span>ersetzen</li><li>Aktuell als Sonderfall einer Component<span class="widont">&nbsp;</span>beschrieben</li><li>Wird automatisch zur Laufzeit für jede Route generiert, falls nicht<span class="widont">&nbsp;</span>vorhanden</li><li>Jede Route hat aktuell einen Controller mit <code>model</code> Eigenschaft</li><li>Reagiert auf Actions im<span class="widont">&nbsp;</span>Template</li></ul></section><section id="ember-data" class="slides__slide"><h2 id="ember-data">Ember Data</h2><ul><li>Kein fester, aber empfohlener Bestandteil von<span class="widont">&nbsp;</span>Ember</li><li>Abstrahiert die Kommunikation mit <span class="caps">JSONAPI</span>-/<span class="caps">REST</span>-basierten<span class="widont">&nbsp;</span>APIs</li><li>Persistance Layer inkl. Rollback und<span class="widont">&nbsp;</span>Caching</li><li>Andere Formate durch Adapter und Serializer relativ leicht<span class="widont">&nbsp;</span>umzusetzen</li><li>Adapter und Serializer für jedes Model einzeln<span class="widont">&nbsp;</span>anpassbar</li><li>Stream- und Promise-basiert</li></ul></section><section id="models" class="slides__slide"><h2 id="models">Models</h2><ul><li>Beschreiben Struktur der Inhalte eines<span class="widont">&nbsp;</span><span class="caps">API</span>-Endpunkts</li></ul><pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="caps">DS</span>.Model.extend({
    name: attr(<span class="hljs-string">'string'</span>),
    age: attr(<span class="hljs-string">'number'</span>),
    parents: hasMany(<span class="hljs-string">'person'</span>, {
        <span class="hljs-keyword">async</span>: <span class="hljs-literal">true</span>,
    })
});
</code></pre></section><section id="ember-inspector" class="slides__slide"><h2 id="ember-inspector">Ember Inspector</h2><p>Ein Browser-Addon für Chrome und Firefox sowie ein Bookmarklet für alle anderen<span class="widont">&nbsp;</span>Brower.</p><ul><li>Schneller Überblick über aktive Routes, Views,<span class="widont">&nbsp;</span>Components</li><li>Promise-Debugger für alle in Ember genutzten<span class="widont">&nbsp;</span>Promises</li><li>Daten-Ansicht für sämtliche Datensätze und deren Zustände im Store von Ember<span class="widont">&nbsp;</span>Data</li><li>Gesammelte Deprecation Nachrichten</li><li>Render Performance Informationen</li></ul></section><section id="ember-cli" class="slides__slide"><h2 id="ember-cli">Ember <span class="caps">CLI</span></h2><p>Webpack, Grunt, Gulp, Composer <span class="amp">&amp;</span> Co? Nicht<span class="widont">&nbsp;</span>nötig.</p><ul><li>Developement Server mit<span class="widont">&nbsp;</span>Live-Reload</li><li>Generatoren <span class="amp">&amp;</span> Blueprints für sämtliche Bestandteile von<span class="widont">&nbsp;</span>Ember</li><li>Update-Management</li><li>Production Builds inkl.<span class="widont">&nbsp;</span>Optimierung</li><li>Addon-System</li><li>Testing</li></ul></section><section id="addons" class="slides__slide"><h2 id="addons">Addons</h2><ul><li>Funktionen für eine App (Components, sogar ganze<span class="widont">&nbsp;</span>Apps)</li><li>Funktionen für den Build-Prozess (<span class="caps">SASS</span>, ESLint, zusätzliche<span class="widont">&nbsp;</span>Blueprints)</li></ul><h3 id="beliebte-addons">Beliebte Addons</h3><ul><li>Ember Simple Auth: Abstrahiert Authentifizierung, inkl.<span class="widont">&nbsp;</span>Login</li><li>ember-i18n: Lokalisierung</li><li>cp-validations: Lazy Validierung von Models und beliebigen<span class="widont">&nbsp;</span>Objekten</li></ul></section><section id="why-ember" class="slides__slide"><h2 id="warum-ember-">Warum Ember?</h2><ul><li>auch nach mittlerweile vier Jahren immer<span class="widont">&nbsp;</span>zuverlässig</li><li>Testing und Langlebigkeit von<span class="widont">&nbsp;</span>Projekten</li><li>Klare Sturukturen auch für große<span class="widont">&nbsp;</span>Projekte</li><li>Mittlerweile relativ einfacher<span class="widont">&nbsp;</span>Einstieg</li><li>Hilfsbereite Community</li><li>Projekte wie Glimmer zeigen, dass Fortschritt möglich ist, ohne immer wieder von Vorn anfangen zu<span class="widont">&nbsp;</span>müssen.</li></ul></section><section id="questions" class="slides__slide--title"><h1 id="fragen-">Fragen?</h1><p>Gerne jetzt, oder jederzeit auf den üblichen<span class="widont">&nbsp;</span>Kanälen.</p></section><section id="thanks" class="slides__slide--title"><h1 id="danke-f-rs-zuh-ren">Danke fürs Zuhören</h1><p>Florian Pichler / @pichfl /<span class="widont">&nbsp;</span>fp@ylk.gd</p></section></article></div><script src="//pichfl.github.io/talks/assets/bundle.4b8db7c1.js"></script></body></html>